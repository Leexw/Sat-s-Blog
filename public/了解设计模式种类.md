很久之前就买了设计模式那本书，一直都没看下去，原因到了今天才发现，就是抽象工厂模式，实在是太过晦涩，读起来太费劲，太通用了就很难理解。

后来在网上寻找工厂方法模式的解释，发现一个好网站[图说设计模式](http://design-patterns.readthedocs.org/zh_CN/latest/index.html)，写得真是很好。

简单记录一下自己的理解
###常见的设计模式
####创建型模式
**工厂模式**：`统一的初始化`。分为简单工厂模式、工厂方法模式、抽象工厂模式。

-	简单工厂模式，可概括为在工厂类提供接口，并在工厂类完成所有产品的初始化。
-	工厂方法模式，可概括为在工厂类提供接口，在具体子工厂类中完成产品的初始化。
-	抽象工厂模式，没搞懂，说是最通用、最具一般性的工厂模式。
总的来说，就是提供统一的接口进行初始化，实现上并符合开闭原则。

**建造者模式**：`抽离初始化`。这个比较好理解，就是抽离初始化的逻辑，使之与其他逻辑解耦。

**单例模式**：用得太多了，就是确保只有一个实例，并提供全局可访问的方法。
此外，还有多例模式，是单例的推广，例如GCD的线程池。

**原型模式**：使用存在的实例进行拷贝，以声称实例的方法。例如OC中生成对象就是通过原型模式，是通过拷贝类对象的原型来生成的。

**惰性初始化模式**：这个在iOS开发中也很常见，就是推迟对象的初始化，直到需要使用到的时候才进行创建，用于提高性能。

**对象池模式**：通过回收对象来避免不停地初始化与释放，在以前的下载库也是使用到。


####结构型模式

**适配器模式**：`新瓶装旧酒`。提供所需接口给使用者。

**桥接模式（Bridge Pattern）**：`继承转关联`。用意是使得类与类之间解藕，由继承关系改成关联关系，使得两个类可以独立变化，所以叫做桥接模式

**装饰模式（Decorator Pattern）**：`通过重新包装新增特性`。通过包装已有类，给原有类添加新功能的方式，而非继承非扩展，则为装饰模式。这也是一种松耦合，符合开闭原则。

**门面模式（Facade Pattern）**：`统一接口`。提供统一的外部接口的模式，与工厂方法有些类似，不过这里不是指初始化，是一种对象结构型模式。违反开闭原则。

**享元模式（Flyweight Pattern）**：跟对象池模式类似，只是这里更细粒度，通过构建对象的结构，分为内部状态和外部状态，内部状态是共性，外部状态表示个性特征。所以这种模式称为对象结构型模式。

**代理模式（Proxy pattern）**：通过第三方实现某些功能的方式，能提高通用性，更加灵活。

####行为型模式

**命令模式（Command Pattern）**：`将消息与接收者封装为命令对象`。将命令请求和接收者进行封装对象，但发送者不知道接收者是谁，发送者只发送封装后的命令对象，使得发送者与接收者完全解耦。

**中介者模式（Mediator Pattern）**：`通过中介给强关联对象解耦`。用于解决对象间具有强烈关联关系的耦合，通过中介者将二者关联起来，从而两者关系耦合度大大降低。

**观察者模式（Observer Pattern）**：`发布－订阅`。在iOS开发中很常见。与命令模式很像，但区别在于观察者模式中发送者和消息对象都不知道接收者是谁。也叫做发布－订阅模式。

**状态模式（State Pattern）**：没什么好通用的，就是可通过状态变化而改变对象的行为。

**策略模式（）**：`低成本地替换方案`。封装好一系列同等作用的解决策略，并可以方便替换。使得解决策略可以独立变化。


###设计模式的六大原则

上诉设计模式可以好好理解，并拿来就用，但千万不束缚了自己创造力。有效果的就是好招。

看到这篇关于设计原则的[文章](http://www.uml.org.cn/sjms/201211023.asp)，可以看看

**单一职责**：一个类做好一件事。

**里氏替换**：父类对象能够完全被子类对象替换，而不改变行为。

**依赖倒置**：细节应该依赖于抽象，而不应该依赖于细节。相对于细节的多变性，抽象的东西要稳定的多。不是很好理解，觉得这个原则不太像原则。这里改成`依赖抽象`好像更合适。

**接口隔离**：这个不算什么原则。定义是客户不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。 

**迪米特法则(Law of Demeter)**：最少关联原则。一个对象应该对其他对象保持最少了解。

**开闭原则**：对扩展开放，并修改关闭。

